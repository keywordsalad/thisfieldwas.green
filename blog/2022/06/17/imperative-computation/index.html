<!doctype html>
<html lang="en" prefix="og: https://ogp.me/ns#">
<head>

<meta charset="utf-8">
<meta http-equiv="x-ua-compatible" content="ie=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>This Field Was Green - Embracing Nondeterminism Part III: Imperative Computation</title>
<link rel="canonical" href="https://thisfieldwas.green/blog/2022/06/17/imperative-computation/">
<link rel="shortcut icon" sizes="16x16 32x32 48x48 64x64 96x96 128x128 256x256" href="https://thisfieldwas.green/favicon.ico">

<meta property="og:site_name" content="">
<meta property="og:title" content="Embracing Nondeterminism Part III: Imperative Computation">
<meta property="og:url" content="https://thisfieldwas.green/blog/2022/06/17/imperative-computation/">
<meta property="og:description" content="Leveraging the case of the previous effect to indicate whether computation of the next effect should proceed.">
<meta property="og:image:url" content="https://thisfieldwas.green/images/tags/functional-programming/functional-grass-512x512.png">
<meta property="og:image:alt" content="Leveraging the case of the previous effect to indicate whether computation of the next effect should proceed.">
<meta property="article:published_time" content="2022-06-17T08:47:11-07:00">
  <meta property="article:modified_time" content="2022-06-17T08:47:11-07:00">
  <meta property="article:author" content="Logan McGrath">
  <meta property="article:tag" content="functional programming">
  <meta property="article:tag" content="programming">
  <meta property="article:tag" content="scala">
  <meta property="article:tag" content="design patterns">
  <meta property="article:tag" content="contexts">
  
<meta name="twitter:card" content="summary">
<meta name="twitter:site" content="@thisgreenfield">
<meta name="twitter:title" content="Embracing Nondeterminism Part III: Imperative Computation">
<meta name="twitter:description" content="Leveraging the case of the previous effect to indicate whether computation of the next effect should proceed.">
<meta name="twitter:image" content="https://thisfieldwas.green/images/tags/functional-programming/functional-grass-512x512.png">

<link rel="stylesheet" href="/css/main.css" media="print" onload="this.media='all'">
<script src="/js/main.js" async></script>
<script src="/js/scroll-shadows.js" async></script>
<script>
  let scrollShadowsXSelectors = ["pre.sourceCode",]
  let scrollShadowsYSelectors = []
  window.addEventListener("load", () => {
    scrollShadowsXSelectors.forEach(updateScrollShadowsXSelector)
    scrollShadowsYSelectors.forEach(updateScrollShadowsYSelector)
  })
  window.addEventListener("resize", () => {
    scrollShadowsXSelectors.forEach(updateScrollShadowsXSelector)
  })
</script>


</head>
<body>

<header class="page-header">
  <div class="content-bound">
    <div class="logo-icon"><a href="/" tabindex="-1" title="This Field Was Green"></a></div>
    <div class="logo-nav">
      <h1 class="logo"><a href="/">This Field Was Green</a></h1>
      <nav class="main-nav">
  <a href="/">Home</a>
  <a href="/blog/">Blog</a>
  <a href="/resume/">Resume</a>
  <a href="/contact/">Contact</a>
</nav>

    </div>
  </div>
</header>

<main class="page-content">
  <div class="content-bound">
    <div class="post post-full">
      <h1 class="post-title">Embracing Nondeterminism Part III: Imperative Computation</h1>
<div class="post-meta">
  <p class="post-published">
    Posted on June 17, 2022
    by Logan McGrath
    </p>
  <p class="post-tags">
      Tags: <a class="tag" href="/tags/functional-programming">functional programming</a>, <a class="tag" href="/tags/programming">programming</a>, <a class="tag" href="/tags/scala">scala</a>, <a class="tag" href="/tags/design-patterns">design patterns</a>, <a class="tag" href="/tags/contexts">contexts</a>
    </p>
  </div>



<div class="estimated-reading-time">
<p>Estimated reading time: <span class="length">21m 28s</span></p>
</div>
<p>Remember <strong>functors</strong> and <strong>applicatives</strong>? In my last post <a href="/blog/2022/06/05/permitting-or-halting-computation/">Embracing Nondeterminism Part II: Permitting or Halting Computation</a> we explored how functors and applicatives abstract over <strong>desired</strong> and <strong>undesired cases</strong> of <strong>contexts</strong> in order to express control flow and permit independent computation. In this post we will explore <strong>monads</strong> and how to leverage their specific abstraction to express <strong>imperative</strong> control flow.</p>
<!--more-->
<blockquote>
<p><strong>This post is part of a series:</strong></p>
<ol type="1">
<li><a href="/blog/2022/03/15/contexts-and-effects/">Embracing Nondeterminism Part I: Contexts and Effects</a></li>
<li><a href="/blog/2022/06/05/permitting-or-halting-computation/">Embracing Nondeterminism Part II: Permitting or Halting Computation</a></li>
<li><strong>Embracing Nondeterminism Part III: Imperative Computation</strong></li>
</ol>
</blockquote>
<p><em>The code that accompanies this post may be found <a href="https://bitsof.thisfieldwas.green/keywordsalad/embracing-nondeterminism-code/src/branch/part3">here</a>.</em></p>
<h2 id="motivating-monads-as-a-design-pattern">Motivating monads as a design pattern</h2>
<p>Recall the <code>Functor</code> and <code>Applicative</code> typeclasses:</p>
<div class="numberLines">
<div class="sourceCode" id="cb1"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">trait</span> Functor<span class="op">[</span>F<span class="op">[</span>_<span class="op">]]</span> <span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> map<span class="op">[</span>A<span class="op">,</span> B<span class="op">](</span>fa<span class="op">:</span> F<span class="op">[</span>A<span class="op">])(</span>f<span class="op">:</span> A <span class="op">=&gt;</span> B<span class="op">):</span> F<span class="op">[</span>B<span class="op">]</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">object</span> Functor <span class="op">{</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> apply<span class="op">[</span>F<span class="op">[</span>_<span class="op">]:</span> Functor<span class="op">]:</span> Functor<span class="op">[</span>F<span class="op">]</span> <span class="op">=</span> implicitly<span class="op">[</span>Functor<span class="op">[</span>F<span class="op">]]</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="kw">trait</span> Applicative<span class="op">[</span>F<span class="op">[</span>_<span class="op">]]</span> <span class="kw">extends</span> Functor<span class="op">[</span>F<span class="op">]</span> <span class="op">{</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> pure<span class="op">[</span>A<span class="op">](</span>a<span class="op">:</span> A<span class="op">):</span> F<span class="op">[</span>A<span class="op">]</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> ap<span class="op">[</span>A<span class="op">,</span> B<span class="op">](</span>ff<span class="op">:</span> F<span class="op">[</span>A <span class="op">=&gt;</span> B<span class="op">])(</span>fa<span class="op">:</span> F<span class="op">[</span>A<span class="op">]):</span> F<span class="op">[</span>B<span class="op">]</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> map<span class="op">[</span>A<span class="op">,</span> B<span class="op">](</span>fa<span class="op">:</span> F<span class="op">[</span>A<span class="op">]):</span> F<span class="op">[</span>B<span class="op">]</span> <span class="op">=</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>    <span class="fu">ap</span><span class="op">(</span><span class="fu">pure</span><span class="op">(</span>f<span class="op">))(</span>fa<span class="op">)</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> map2<span class="op">[</span>A<span class="op">,</span> B<span class="op">,</span> C<span class="op">](</span>fa<span class="op">:</span> F<span class="op">[</span>A<span class="op">],</span> fb<span class="op">:</span> F<span class="op">[</span>B<span class="op">])(</span>f<span class="op">:</span> <span class="op">(</span>A<span class="op">,</span> B<span class="op">)</span> <span class="op">=&gt;</span> C<span class="op">):</span> F<span class="op">[</span>C<span class="op">]</span> <span class="op">=</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>    <span class="fu">ap</span><span class="op">(</span><span class="fu">ap</span><span class="op">(</span><span class="fu">pure</span><span class="op">(</span>f<span class="op">.</span>curried<span class="op">))(</span>fa<span class="op">))(</span>fb<span class="op">)</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> sequence<span class="op">[</span>A<span class="op">](</span>listFa<span class="op">:</span> <span class="ex">List</span><span class="op">[</span>F<span class="op">[</span>A<span class="op">]]):</span> F<span class="op">[</span><span class="ex">List</span><span class="op">[</span>A<span class="op">]]</span> <span class="op">=</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>    listFa<span class="op">.</span><span class="fu">foldLeft</span><span class="op">(</span><span class="fu">pure</span><span class="op">(</span><span class="ex">List</span><span class="op">[</span>A<span class="op">]()))((</span>fListA<span class="op">,</span> fa<span class="op">)</span> <span class="op">=&gt;</span> <span class="fu">map2</span><span class="op">(</span>fa<span class="op">,</span> fListA<span class="op">)(</span>_ <span class="op">::</span> _<span class="op">))</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a><span class="kw">object</span> Applicative <span class="op">{</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> apply<span class="op">[</span>F<span class="op">:</span> Applicative<span class="op">]:</span> Applicative<span class="op">[</span>F<span class="op">]</span> <span class="op">=</span> implicitly<span class="op">[</span>Applicative<span class="op">[</span>F<span class="op">]]</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
<blockquote>
<p>See <a href="https://bitsof.thisfieldwas.green/keywordsalad/embracing-nondeterminism-code/src/branch/part3/src/main/scala/green/thisfieldwas/embracingnondeterminism/data/Functor.scala"><code>Functor</code></a>
and <a href="https://bitsof.thisfieldwas.green/keywordsalad/embracing-nondeterminism-code/src/branch/part3/src/main/scala/green/thisfieldwas/embracingnondeterminism/control/Applicative.scala"><code>Applicative</code>’s</a>
definitions in the sample repository.</p>
</blockquote>
<p><code>Functor</code> abstracts over contexts’ <strong>unknown cases</strong> by <em>lifting</em> a function via <code>map()</code> and applying it to instances of the term produced by the context if they exist. Control flow can’t be expressed using <code>map()</code> because it does not permit the case of the context to be modified.</p>
<p><code>Applicative</code> can create contexts in the <strong>desired case</strong> via <code>pure()</code>. It can also apply <em>lifted</em> functions to <em>lifted</em> arguments via <code>ap()</code> if <em>both</em> contexts are in their <strong>desired case</strong>. <code>Applicative</code> is capable of expressing control flow through <code>ap()</code> because supplying either the lifted function or lifted argument in an <strong>undesired case</strong> will not permit further computation. The context in the <strong>undesired case</strong> is <em>propagated</em> instead.</p>
<p>The problem however is that <code>Applicative</code> requires that <em>both</em> the lifted function and lifted argument supplied to <code>ap()</code> be computed <em>before</em> deciding whether to permit or halt further computation. This means that regardless of whether one of the function or argument contexts successfully computes, if the other one fails then the succeeding computation will be discarded. Both of these contexts’ computation are independent, and <code>Applicative</code> will only use them if they are both are in their <strong>desired case</strong>.</p>
<p>All functions derived from <code>ap()</code> represent <em>all-or-nothing</em> operations accordingly, and there is no practical way of ordering the computation of the arguments or preventing computation of all arguments if any preceding arguments fail to compute. Therefore, totally imperative programming is not possible using <code>Applicative</code>.</p>
<h2 id="introducing-imperative-control-flow">Introducing imperative control flow</h2>
<p>In order to restrict computation such that subsequent computation occurs only if previous computation succeeds, we must introduce a new abstraction over the cases of contexts.</p>
<p>What function might limit subsequent computations from running if a previous one has failed? There is one, and you’ve probably seen it out in the wild:</p>
<div class="numberLines">
<div class="sourceCode" id="cb2"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> flatMap<span class="op">[</span>F<span class="op">[</span>_<span class="op">],</span> A<span class="op">,</span> B<span class="op">](</span>fa<span class="op">:</span> F<span class="op">[</span>A<span class="op">])(</span>f<span class="op">:</span> A <span class="op">=&gt;</span> F<span class="op">[</span>B<span class="op">]):</span> F<span class="op">[</span>B<span class="op">]</span></span></code></pre></div>
</div>
<p>What <code>flatMap()</code> does is allow for the injection of a context into a pipeline of computations to either permit computation to proceed or force it to halt. The function argument <code>f</code>, which you supply, has full control of what case the returned context <code>F[B]</code> should be in. If <code>F[B]</code> is in the <strong>undesired case</strong>, then all further computations are skipped, <em>propagating</em> this <strong>undesired case</strong> instead.</p>
<p>Take for example this definition of a <code>filter()</code> function from the sample repository’s <code>sbt console</code>:</p>
<div class="numberLines">
<div class="sourceCode" id="cb3"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>scala<span class="op">&gt;</span> <span class="op">:</span>load console<span class="op">/</span>imports<span class="op">.</span>scala</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>scala<span class="op">&gt;</span> <span class="kw">def</span> filter<span class="op">[</span>A<span class="op">](</span>fa<span class="op">:</span> <span class="ex">Option</span><span class="op">[</span>A<span class="op">])(</span>f<span class="op">:</span> A <span class="op">=&gt;</span> <span class="ex">Boolean</span><span class="op">)</span> <span class="op">=</span> fa<span class="op">.</span>flatMap <span class="op">{</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>     <span class="op">|</span>   <span class="cf">case</span> a <span class="cf">if</span> <span class="fu">f</span><span class="op">(</span>a<span class="op">)</span> <span class="op">=&gt;</span> <span class="bu">Some</span><span class="op">(</span>a<span class="op">)</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>     <span class="op">|</span>   <span class="cf">case</span> _ <span class="op">=&gt;</span> <span class="bu">None</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>     <span class="op">|</span> <span class="op">}</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> filter<span class="op">[</span>A<span class="op">](</span>fa<span class="op">:</span> <span class="ex">Option</span><span class="op">[</span>A<span class="op">])(</span>f<span class="op">:</span> A <span class="op">=&gt;</span> <span class="ex">Boolean</span><span class="op">):</span> <span class="ex">Option</span><span class="op">[</span>A<span class="op">]</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>scala<span class="op">&gt;</span> <span class="fu">filter</span><span class="op">(</span><span class="bu">Some</span><span class="op">(</span><span class="dv">4</span><span class="op">))(</span>_ <span class="op">%</span> <span class="dv">2</span> <span class="op">==</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> res1<span class="op">:</span> <span class="ex">Option</span><span class="op">[</span><span class="bu">Int</span><span class="op">]</span> <span class="op">=</span> <span class="bu">Some</span><span class="op">(</span><span class="dv">4</span><span class="op">)</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>scala<span class="op">&gt;</span> <span class="fu">filter</span><span class="op">(</span><span class="bu">Some</span><span class="op">(</span><span class="dv">3</span><span class="op">))(</span>_ <span class="op">%</span> <span class="dv">2</span> <span class="op">==</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> res2<span class="op">:</span> <span class="ex">Option</span><span class="op">[</span><span class="bu">Int</span><span class="op">]</span> <span class="op">=</span> <span class="bu">None</span></span></code></pre></div>
</div>
<p>This example is only very simple. But it demonstrates the key enabling feature of <code>flatMap()</code>: we are able to <em>choose</em> whether the context remains in its <strong>desired case</strong>. If we continue with this example, we can try chaining <code>map()</code> to the context returned by it.</p>
<div class="numberLines">
<div class="sourceCode" id="cb4"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>scala<span class="op">&gt;</span> <span class="fu">filter</span><span class="op">(</span><span class="bu">Some</span><span class="op">(</span><span class="dv">4</span><span class="op">))(</span>_ <span class="op">%</span> <span class="dv">2</span> <span class="op">==</span> <span class="dv">0</span><span class="op">).</span><span class="fu">map</span><span class="op">(</span>n <span class="op">=&gt;</span> <span class="ss">s&quot;</span><span class="st">The square of even number </span><span class="ss">$n</span><span class="st"> is </span><span class="ss">${</span>n <span class="op">*</span> n<span class="ss">}&quot;</span><span class="op">)</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> res3<span class="op">:</span> <span class="ex">Option</span><span class="op">[</span><span class="ex">String</span><span class="op">]</span> <span class="op">=</span> <span class="bu">Some</span><span class="op">(</span>The square of even number <span class="dv">4</span> is <span class="dv">16</span><span class="op">)</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>scala<span class="op">&gt;</span> <span class="fu">filter</span><span class="op">(</span><span class="bu">Some</span><span class="op">(</span><span class="dv">3</span><span class="op">))(</span>_ <span class="op">%</span> <span class="dv">2</span> <span class="op">==</span> <span class="dv">0</span><span class="op">).</span><span class="fu">map</span><span class="op">(</span>n <span class="op">=&gt;</span> <span class="ss">s&quot;</span><span class="st">The square of even number </span><span class="ss">$n</span><span class="st"> is </span><span class="ss">${</span>n <span class="op">*</span> n<span class="ss">}&quot;</span><span class="op">)</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> res4<span class="op">:</span> <span class="ex">Option</span><span class="op">[</span><span class="ex">String</span><span class="op">]</span> <span class="op">=</span> <span class="bu">None</span></span></code></pre></div>
</div>
<p>Thus we are able to gate <code>map()</code> behind the case of the context we return from the <code>flatMap()</code> we used in <code>filter()</code>, enabling imperative control flow.</p>
<h2 id="monads">Monads</h2>
<p>The <code>flatMap()</code> function is implemented using a new structure, a specialization of an applicative functor called a <strong>monad</strong>.</p>
<p>Monads are a specialization that arises in the type of <code>A</code> contained within a context <code>F[_]</code>:</p>
<ul>
<li>If <code>A</code> is an opaque type, then <code>F[A]</code> is a <strong>functor</strong>.</li>
<li>If <code>A</code> is known to have type <code>A =&gt; B</code>, that is <em><code>A</code> is a function</em>, then <code>F[A =&gt; B]</code> is an <strong>applicative</strong> functor.</li>
<li>If <code>A</code> is known to have type <code>F[A]</code>, then this means that <code>F[F[A]]</code> is <em>nested within itself</em> and thus a <strong>monad</strong>.</li>
</ul>
<p>The <code>Monad</code> typeclass defines two functions, which by default are defined in terms of each other:</p>
<div class="numberLines">
<div class="sourceCode" id="cb5"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">trait</span> Monad<span class="op">[</span>F<span class="op">[</span>_<span class="op">]]</span> <span class="kw">extends</span> Applicative<span class="op">[</span>F<span class="op">]</span> <span class="op">{</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> flatMap<span class="op">[</span>A<span class="op">,</span> B<span class="op">](</span>fa<span class="op">:</span> F<span class="op">[</span>A<span class="op">])(</span>f<span class="op">:</span> A <span class="op">=&gt;</span> F<span class="op">[</span>B<span class="op">]):</span> F<span class="op">[</span>B<span class="op">]</span> <span class="op">=</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">flatten</span><span class="op">(</span><span class="fu">map</span><span class="op">(</span>fa<span class="op">)(</span>f<span class="op">))</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> flatten<span class="op">[</span>A<span class="op">](</span>ffa<span class="op">:</span> F<span class="op">[</span>F<span class="op">[</span>A<span class="op">]]):</span> F<span class="op">[</span>A<span class="op">]</span> <span class="op">=</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    <span class="fu">flatMap</span><span class="op">(</span>fa <span class="op">=&gt;</span> fa<span class="op">)</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a><span class="kw">object</span> Monad <span class="op">{</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> apply<span class="op">[</span>F<span class="op">[</span>_<span class="op">]:</span> Monad<span class="op">]:</span> Monad<span class="op">[</span>F<span class="op">]</span> <span class="op">=</span> implicitly<span class="op">[</span>Monad<span class="op">[</span>F<span class="op">]]</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
<p>This means that in order to implement an instance of the <code>Monad</code> typeclass, you must implement one of either <code>flatMap()</code> or <code>flatten()</code> or calling one will recurse until the stack overflows. Some contexts are best defined using one over the other, and you have the choice to pick between the two.</p>
<blockquote>
<p><a href="https://bitsof.thisfieldwas.green/keywordsalad/embracing-nondeterminism-code/src/branch/part3/src/main/scala/green/thisfieldwas/embracingnondeterminism/control/Monad.scala">See here</a> for the definition in the sample repository.</p>
</blockquote>
<h3 id="composing-monads">Composing monads</h3>
<p><code>Monad</code> also defines a special composition operator. Recall that functions may be composed together, as in <code>h = g ∘ f</code> or <em>“h is g after f”</em>. This may be expressed in two ways in vanilla Scala. Try below using the sample repository’s <code>sbt console</code>:</p>
<div class="numberLines">
<div class="sourceCode" id="cb6"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>scala<span class="op">&gt;</span> <span class="kw">val</span> f<span class="op">:</span> <span class="bu">Int</span> <span class="op">=&gt;</span> <span class="ex">String</span> <span class="op">=</span> n <span class="op">=&gt;</span> <span class="op">(</span>n <span class="op">*</span> n<span class="op">).</span>toString</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> f<span class="op">:</span> <span class="bu">Int</span> <span class="op">=&gt;</span> <span class="ex">String</span> <span class="op">=</span> $Lambda$<span class="dv">5252</span><span class="op">/</span><span class="bn">0x000000010195e040</span>@7a76dc63</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>scala<span class="op">&gt;</span> <span class="kw">val</span> g<span class="op">:</span> <span class="ex">String</span> <span class="op">=&gt;</span> <span class="bu">Int</span> <span class="op">=</span> n <span class="op">=&gt;</span> n<span class="op">.</span>length</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> g<span class="op">:</span> <span class="ex">String</span> <span class="op">=&gt;</span> <span class="bu">Int</span> <span class="op">=</span> $Lambda$<span class="dv">5254</span><span class="op">/</span><span class="bn">0x000000010195f840</span>@<span class="dv">3843085</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>scala<span class="op">&gt;</span> <span class="kw">val</span> h <span class="op">=</span> g<span class="op">.</span><span class="fu">compose</span><span class="op">(</span>f<span class="op">)</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> h<span class="op">:</span> <span class="bu">Int</span> <span class="op">=&gt;</span> <span class="bu">Int</span> <span class="op">=</span> scala<span class="op">.</span>Function1$$Lambda$<span class="dv">5244</span><span class="op">/</span><span class="bn">0x0000000101958840</span>@388b1b42</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>scala<span class="op">&gt;</span> <span class="fu">h</span><span class="op">(</span><span class="dv">3</span><span class="op">)</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> res1<span class="op">:</span> <span class="bu">Int</span> <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>scala<span class="op">&gt;</span> <span class="fu">h</span><span class="op">(</span><span class="dv">25</span><span class="op">)</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> res2<span class="op">:</span> <span class="bu">Int</span> <span class="op">=</span> <span class="dv">3</span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>scala<span class="op">&gt;</span> <span class="kw">val</span> hh <span class="op">=</span> f<span class="op">.</span><span class="fu">andThen</span><span class="op">(</span>g<span class="op">)</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>scala<span class="op">&gt;</span> <span class="fu">hh</span><span class="op">(</span><span class="dv">3</span><span class="op">)</span></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> res3<span class="op">:</span> <span class="bu">Int</span> <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>scala<span class="op">&gt;</span> <span class="fu">hh</span><span class="op">(</span><span class="dv">25</span><span class="op">)</span></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> res4<span class="op">:</span> <span class="bu">Int</span> <span class="op">=</span> <span class="dv">3</span></span></code></pre></div>
</div>
<p>Scala out of the box affords the <code>compose()</code> and <code>andThen()</code> functions for composing functions of the form of <code>A =&gt; B</code> together. But these composition functions don’t work for the signature of <code>flatMap()</code>, which operates on functions of the form of <code>A =&gt; F[B]</code>.</p>
<p>There is a form of composition for monads known as <em><a href="https://blog.ploeh.dk/2022/04/04/kleisli-composition/">Kleisli composition</a></em>. This composition will lift the following function into the context returned by the previous function and apply it to the term contained within the context if the context is in the <strong>desired case</strong>. Kleisli composition is expressed using the <em>fish</em> or <em>arrow operator</em> <code>&gt;=&gt;</code> which is defined in the sample repository as an extension operator on functions of the form <code>A =&gt; F[B]</code> where <code>F[_]</code> has an instance of <code>Monad</code>:</p>
<div class="numberLines">
<div class="sourceCode" id="cb7"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">implicit</span> <span class="kw">class</span> KleisliCompositionOps<span class="op">[</span>F<span class="op">[</span>_<span class="op">],</span> A<span class="op">,</span> B<span class="op">](</span><span class="kw">val</span> f<span class="op">:</span> A <span class="op">=&gt;</span> F<span class="op">[</span>B<span class="op">])</span> <span class="kw">extends</span> AnyVal <span class="op">{</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> <span class="op">&gt;=&gt;[</span>C<span class="op">](</span>g<span class="op">:</span> B <span class="op">=&gt;</span> F<span class="op">[</span>C<span class="op">])(</span><span class="kw">implicit</span> F<span class="op">:</span> Monad<span class="op">[</span>F<span class="op">]):</span> A <span class="op">=&gt;</span> F<span class="op">[</span>C<span class="op">]</span> <span class="op">=</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">(</span>x<span class="op">:</span> A<span class="op">)</span> <span class="op">=&gt;</span> F<span class="op">.</span><span class="fu">flatMap</span><span class="op">(</span><span class="fu">f</span><span class="op">(</span>x<span class="op">))(</span>g<span class="op">)</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
<blockquote>
<p><a href="https://bitsof.thisfieldwas.green/keywordsalad/embracing-nondeterminism-code/src/branch/part3/src/main/scala/green/thisfieldwas/embracingnondeterminism/syntax/monad.scala#L48">See here</a> for the definition in the sample repository.</p>
</blockquote>
<p>Kleisli composition is useful for monads in that from two or more <code>flatMap()</code>-compatible functions a single function may be created that takes an unlifted argument and produces an output context as the result of applying each function in sequence first to the unlifted argument and then to each individual functions’ output contexts.</p>
<div class="numberLines">
<div class="sourceCode" id="cb8"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>scala<span class="op">&gt;</span> <span class="op">:</span>load console<span class="op">/</span>imports<span class="op">.</span>scala</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>scala<span class="op">&gt;</span> <span class="kw">val</span> squareEvens<span class="op">:</span> <span class="bu">Int</span> <span class="op">=&gt;</span> Either<span class="op">[</span><span class="ex">String</span><span class="op">,</span> <span class="bu">Int</span><span class="op">]</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>     <span class="op">|</span>   <span class="cf">case</span> n <span class="cf">if</span> n <span class="op">%</span> <span class="dv">2</span> <span class="op">==</span> <span class="dv">0</span> <span class="op">=&gt;</span> Either<span class="op">.</span>right<span class="op">[</span><span class="ex">String</span><span class="op">,</span> <span class="bu">Int</span><span class="op">](</span>n <span class="op">*</span> n<span class="op">)</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>     <span class="op">|</span>   <span class="cf">case</span> n               <span class="op">=&gt;</span> Either<span class="op">.</span>left<span class="op">[</span><span class="ex">String</span><span class="op">,</span> <span class="bu">Int</span><span class="op">](</span><span class="ss">s&quot;$n</span><span class="st"> is an odd number</span><span class="ss">&quot;</span><span class="op">)</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>     <span class="op">|</span> <span class="op">}</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> squareEvens<span class="op">:</span> <span class="bu">Int</span> <span class="op">=&gt;</span> Either<span class="op">[</span><span class="ex">String</span><span class="op">,</span><span class="bu">Int</span><span class="op">]</span> <span class="op">=</span> $Lambda$<span class="dv">5278</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>scala<span class="op">&gt;</span> <span class="kw">val</span> piEvenLastDigit<span class="op">:</span> <span class="bu">Int</span> <span class="op">=&gt;</span> Either<span class="op">[</span><span class="ex">String</span><span class="op">,</span> <span class="bu">Int</span><span class="op">]</span> <span class="op">=</span> <span class="op">{</span> n <span class="op">=&gt;</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>     <span class="op">|</span>   <span class="kw">val</span> nPi <span class="op">=</span> n <span class="op">*</span> scala<span class="op">.</span>math<span class="op">.</span>Pi</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>     <span class="op">|</span>   <span class="kw">val</span> lastDigit <span class="op">=</span> nPi<span class="op">.</span>toString<span class="op">.</span>last<span class="op">.</span>asDigit</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>     <span class="op">|</span>   <span class="cf">if</span> <span class="op">(</span>lastDigit <span class="op">%</span> <span class="dv">2</span> <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>     <span class="op">|</span>     Either<span class="op">.</span>right<span class="op">[</span><span class="ex">String</span><span class="op">,</span> <span class="bu">Int</span><span class="op">](</span>lastDigit<span class="op">)</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>     <span class="op">|</span>   <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>     <span class="op">|</span>     Either<span class="op">.</span>left<span class="op">[</span><span class="ex">String</span><span class="op">,</span> <span class="bu">Int</span><span class="op">](</span><span class="ss">s&quot;$n</span><span class="st"> * Pi&#39;s last digit is an odd number</span><span class="ss">&quot;</span><span class="op">)</span></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>     <span class="op">|</span>   <span class="op">}</span></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>     <span class="op">|</span> <span class="op">}</span></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>scala<span class="op">&gt;</span> <span class="kw">val</span> evensSquaredWithEvenLastDigitsOfPi <span class="op">=</span> squareEvens <span class="op">&gt;=&gt;</span> piEvenLastDigit</span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> evensSquaredWithEvenLastDigitsOfPi<span class="op">:</span> <span class="bu">Int</span> <span class="op">=&gt;</span> Either<span class="op">[</span><span class="ex">String</span><span class="op">,</span><span class="bu">Int</span><span class="op">]</span> <span class="op">=</span> Monad$Syntax$KleisliCompositionOps$$$Lambda$<span class="dv">5241</span></span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a>scala<span class="op">&gt;</span> <span class="fu">evensSquaredWithEvenLastDigitsOfPi</span><span class="op">(</span><span class="dv">2</span><span class="op">)</span></span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> res1<span class="op">:</span> Either<span class="op">[</span><span class="ex">String</span><span class="op">,</span><span class="bu">Int</span><span class="op">]</span> <span class="op">=</span> <span class="fu">Right</span><span class="op">(</span><span class="dv">2</span><span class="op">)</span></span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a>scala<span class="op">&gt;</span> <span class="fu">evensSquaredWithEvenLastDigitsOfPi</span><span class="op">(</span><span class="dv">23</span><span class="op">)</span></span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> res2<span class="op">:</span> Either<span class="op">[</span><span class="ex">String</span><span class="op">,</span><span class="bu">Int</span><span class="op">]</span> <span class="op">=</span> <span class="fu">Left</span><span class="op">(</span><span class="dv">23</span> is an odd number<span class="op">)</span></span>
<span id="cb8-27"><a href="#cb8-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-28"><a href="#cb8-28" aria-hidden="true" tabindex="-1"></a>scala<span class="op">&gt;</span> <span class="fu">evensSquaredWithEvenLastDigitsOfPi</span><span class="op">(</span><span class="dv">48</span><span class="op">)</span></span>
<span id="cb8-29"><a href="#cb8-29" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> res3<span class="op">:</span> Either<span class="op">[</span><span class="ex">String</span><span class="op">,</span><span class="bu">Int</span><span class="op">]</span> <span class="op">=</span> <span class="fu">Left</span><span class="op">(</span><span class="dv">2304</span> <span class="op">*</span> Pi<span class="er">&#39;</span>s last digit is an odd number<span class="op">)</span></span></code></pre></div>
</div>
<p>Above we are using the composed function directly, but because it has the form of <code>A =&gt; F[B]</code> we are able to apply it using <code>flatMap()</code> as well:</p>
<div class="numberLines">
<div class="sourceCode" id="cb9"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>scala<span class="op">&gt;</span> Either<span class="op">.</span>right<span class="op">[</span><span class="ex">String</span><span class="op">,</span> <span class="bu">Int</span><span class="op">](</span><span class="dv">2</span><span class="op">).</span><span class="fu">flatMap</span><span class="op">(</span>evensSquaredWithEvenLastDigitsOfPi<span class="op">)</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> res4<span class="op">:</span> Either<span class="op">[</span><span class="ex">String</span><span class="op">,</span><span class="bu">Int</span><span class="op">]</span> <span class="op">=</span> <span class="fu">Right</span><span class="op">(</span><span class="dv">2</span><span class="op">)</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>scala<span class="op">&gt;</span> Either<span class="op">.</span>right<span class="op">[</span><span class="ex">String</span><span class="op">,</span> <span class="bu">Int</span><span class="op">](</span><span class="dv">19</span><span class="op">).</span><span class="fu">flatMap</span><span class="op">(</span>evensSquaredWithEvenLastDigitsOfPi<span class="op">)</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> res5<span class="op">:</span> Either<span class="op">[</span><span class="ex">String</span><span class="op">,</span><span class="bu">Int</span><span class="op">]</span> <span class="op">=</span> <span class="fu">Left</span><span class="op">(</span><span class="dv">19</span> is an odd number<span class="op">)</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>scala<span class="op">&gt;</span> Either<span class="op">.</span>right<span class="op">[</span><span class="ex">String</span><span class="op">,</span> <span class="bu">Int</span><span class="op">](</span><span class="dv">4</span><span class="op">).</span><span class="fu">flatMap</span><span class="op">(</span>evensSquaredWithEvenLastDigitsOfPi<span class="op">)</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> res6<span class="op">:</span> Either<span class="op">[</span><span class="ex">String</span><span class="op">,</span><span class="bu">Int</span><span class="op">]</span> <span class="op">=</span> <span class="fu">Left</span><span class="op">(</span><span class="dv">16</span> <span class="op">*</span> Pi<span class="er">&#39;</span>s last digit is an odd number<span class="op">)</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>scala<span class="op">&gt;</span> Either<span class="op">.</span>left<span class="op">[</span><span class="ex">String</span><span class="op">,</span> <span class="bu">Int</span><span class="op">](</span><span class="st">&quot;Nothing&#39;s gonna happen&quot;</span><span class="op">).</span><span class="fu">flatMap</span><span class="op">(</span>evensSquaredWithEvenLastDigitsOfPi<span class="op">)</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> res7<span class="op">:</span> Either<span class="op">[</span><span class="ex">String</span><span class="op">,</span><span class="bu">Int</span><span class="op">]</span> <span class="op">=</span> <span class="fu">Left</span><span class="op">(</span>Nothing<span class="er">&#39;</span>s gonna happen<span class="op">)</span></span></code></pre></div>
</div>
<p>Thus Kleisli composition is to <code>flatMap()</code> as function composition is to <code>map()</code>, with the key difference being that the case of the context may be changed by any one of the composed functions. Kleisli composition is powerful in that entire processes may be composed into step-by-step operations and applied as a single unit to a context via <code>flatMap()</code> or directly to an unlifted argument.</p>
<h3 id="the-for-comprehension-and-imperative-programming">The <em>for comprehension</em> and imperative programming</h3>
<p>Scala provides a syntax sugar over <code>flatMap()</code> in the form of the <em><a href="https://docs.scala-lang.org/tour/for-comprehensions.html">for comprehension</a></em>. Any type that provides both the <code>map()</code> and <code>flatMap()</code> functions are able to participate in this syntax sugar, and it allows for monadic operations to be expressed as if they were written as procedural code. This means that you don’t have to rely on Kleisli composition alone to express complex flows of logic, and that you also aren’t limited to single-argument input/output pipelines of functions.</p>
<p>As a simple example, here are the above functions leveraged using a for comprehension:</p>
<div class="numberLines">
<div class="sourceCode" id="cb10"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>scala<span class="op">&gt;</span> <span class="op">:</span>load console<span class="op">/</span>imports<span class="op">.</span>scala</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>scala<span class="op">&gt;</span> <span class="kw">val</span> squareEvens<span class="op">:</span> <span class="bu">Int</span> <span class="op">=&gt;</span> Either<span class="op">[</span><span class="ex">String</span><span class="op">,</span> <span class="bu">Int</span><span class="op">]</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>     <span class="op">|</span>   <span class="cf">case</span> n <span class="cf">if</span> n <span class="op">%</span> <span class="dv">2</span> <span class="op">==</span> <span class="dv">0</span> <span class="op">=&gt;</span> Either<span class="op">.</span>right<span class="op">[</span><span class="ex">String</span><span class="op">,</span> <span class="bu">Int</span><span class="op">](</span>n <span class="op">*</span> n<span class="op">)</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>     <span class="op">|</span>   <span class="cf">case</span> n               <span class="op">=&gt;</span> Either<span class="op">.</span>left<span class="op">[</span><span class="ex">String</span><span class="op">,</span> <span class="bu">Int</span><span class="op">](</span><span class="ss">s&quot;$n</span><span class="st"> is an odd number</span><span class="ss">&quot;</span><span class="op">)</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>     <span class="op">|</span> <span class="op">}</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> squareEvens<span class="op">:</span> <span class="bu">Int</span> <span class="op">=&gt;</span> Either<span class="op">[</span><span class="ex">String</span><span class="op">,</span><span class="bu">Int</span><span class="op">]</span> <span class="op">=</span> $Lambda$<span class="dv">5278</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>scala<span class="op">&gt;</span> <span class="kw">val</span> piEvenLastDigit<span class="op">:</span> <span class="bu">Int</span> <span class="op">=&gt;</span> Either<span class="op">[</span><span class="ex">String</span><span class="op">,</span> <span class="bu">Int</span><span class="op">]</span> <span class="op">=</span> <span class="op">{</span> n <span class="op">=&gt;</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>     <span class="op">|</span>   <span class="kw">val</span> nPi <span class="op">=</span> n <span class="op">*</span> scala<span class="op">.</span>math<span class="op">.</span>Pi</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>     <span class="op">|</span>   <span class="kw">val</span> lastDigit <span class="op">=</span> nPi<span class="op">.</span>toString<span class="op">.</span>last<span class="op">.</span>asDigit</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>     <span class="op">|</span>   <span class="cf">if</span> <span class="op">(</span>lastDigit <span class="op">%</span> <span class="dv">2</span> <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>     <span class="op">|</span>     Either<span class="op">.</span>right<span class="op">[</span><span class="ex">String</span><span class="op">,</span> <span class="bu">Int</span><span class="op">](</span>lastDigit<span class="op">)</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>     <span class="op">|</span>   <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>     <span class="op">|</span>     Either<span class="op">.</span>left<span class="op">[</span><span class="ex">String</span><span class="op">,</span> <span class="bu">Int</span><span class="op">](</span><span class="ss">s&quot;$n</span><span class="st"> * Pi&#39;s last digit is an odd number</span><span class="ss">&quot;</span><span class="op">)</span></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>     <span class="op">|</span>   <span class="op">}</span></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>     <span class="op">|</span> <span class="op">}</span></span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a>scala<span class="op">&gt;</span> <span class="kw">val</span> evensSquaredWithEvenLastDigitsOfPi<span class="op">:</span> <span class="bu">Int</span> <span class="op">=&gt;</span> Either<span class="op">[</span><span class="ex">String</span><span class="op">,</span> <span class="bu">Int</span><span class="op">]</span> <span class="op">=</span></span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a>     <span class="op">|</span> n <span class="op">=&gt;</span> <span class="cf">for</span> <span class="op">{</span></span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a>     <span class="op">|</span>   squaredEvenN <span class="op">&lt;-</span> <span class="fu">squareEvens</span><span class="op">(</span>n<span class="op">)</span></span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a>     <span class="op">|</span>   piEvenLastDigitN <span class="op">&lt;-</span> <span class="fu">piEvenLastDigit</span><span class="op">(</span>squaredEvenN<span class="op">)</span></span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true" tabindex="-1"></a>     <span class="op">|</span> <span class="op">}</span> <span class="cf">yield</span> piEvenLastDigitN</span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-25"><a href="#cb10-25" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> evensSquaredWithEvenLastDigitsOfPi<span class="op">:</span> <span class="bu">Int</span> <span class="op">=&gt;</span> Either<span class="op">[</span><span class="ex">String</span><span class="op">,</span><span class="bu">Int</span><span class="op">]</span> <span class="op">=</span> $Lambda$<span class="dv">5263</span></span>
<span id="cb10-26"><a href="#cb10-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-27"><a href="#cb10-27" aria-hidden="true" tabindex="-1"></a>scala<span class="op">&gt;</span> <span class="fu">evensSquaredWithEvenLastDigitsOfPi</span><span class="op">(</span><span class="dv">2</span><span class="op">)</span></span>
<span id="cb10-28"><a href="#cb10-28" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> res1<span class="op">:</span> Either<span class="op">[</span><span class="ex">String</span><span class="op">,</span><span class="bu">Int</span><span class="op">]</span> <span class="op">=</span> <span class="fu">Right</span><span class="op">(</span><span class="dv">2</span><span class="op">)</span></span>
<span id="cb10-29"><a href="#cb10-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-30"><a href="#cb10-30" aria-hidden="true" tabindex="-1"></a>scala<span class="op">&gt;</span> Either<span class="op">.</span>right<span class="op">[</span><span class="ex">String</span><span class="op">,</span> <span class="bu">Int</span><span class="op">](</span><span class="dv">2</span><span class="op">).</span><span class="fu">flatMap</span><span class="op">(</span>evensSquaredWithEvenLastDigitsOfPi<span class="op">)</span></span>
<span id="cb10-31"><a href="#cb10-31" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> res2<span class="op">:</span> Either<span class="op">[</span><span class="ex">String</span><span class="op">,</span><span class="bu">Int</span><span class="op">]</span> <span class="op">=</span> <span class="fu">Right</span><span class="op">(</span><span class="dv">2</span><span class="op">)</span></span>
<span id="cb10-32"><a href="#cb10-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-33"><a href="#cb10-33" aria-hidden="true" tabindex="-1"></a>scala<span class="op">&gt;</span> Either<span class="op">.</span>left<span class="op">[</span><span class="ex">String</span><span class="op">,</span> <span class="bu">Int</span><span class="op">](</span><span class="st">&quot;Nothing&#39;s gonna happen&quot;</span><span class="op">).</span><span class="fu">flatMap</span><span class="op">(</span>evensSquaredWithEvenLastDigitsOfPi<span class="op">)</span></span>
<span id="cb10-34"><a href="#cb10-34" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> res3<span class="op">:</span> Either<span class="op">[</span><span class="ex">String</span><span class="op">,</span><span class="bu">Int</span><span class="op">]</span> <span class="op">=</span> <span class="fu">Left</span><span class="op">(</span>Nothing<span class="er">&#39;</span>s gonna happen<span class="op">)</span></span></code></pre></div>
</div>
<p>The key thing that a for comprehension allows for is multiple arguments to be lowered from contexts and applied to a multi-argument function that returns another context. An example of such an operation might look like this:</p>
<div class="numberLines">
<div class="sourceCode" id="cb11"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> <span class="fu">sendMarketingUpdate</span><span class="op">(</span>updateId<span class="op">:</span> <span class="bu">Int</span><span class="op">,</span> userId<span class="op">:</span> <span class="bu">Int</span><span class="op">):</span> <span class="ex">Future</span><span class="op">[</span>MarketingUpdateStatus<span class="op">]</span> <span class="op">=</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">{</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    user <span class="op">&lt;-</span> <span class="fu">loadUser</span><span class="op">(</span>userId<span class="op">)</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    marketingTemplate <span class="op">&lt;-</span> <span class="fu">loadTemplate</span><span class="op">(</span>updateId<span class="op">)</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>    composedEmail <span class="op">&lt;-</span> <span class="fu">composeEmailForUser</span><span class="op">(</span>user<span class="op">,</span> marketingTemplate<span class="op">)</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>    result <span class="op">&lt;-</span> <span class="fu">sendEmail</span><span class="op">(</span>composedEmail<span class="op">)</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span> <span class="cf">yield</span> result<span class="op">.</span>toMarketingUpdateStatus</span></code></pre></div>
</div>
<p>Because <code>composeEmailForUser()</code> requires both a <code>user</code> and <code>marketingTemplate</code>, this operation function is more easily expressed using a for comprehension than Kleisli composition.</p>
<p>However you don’t have to abandon applicative functions when using for comprehensions. The above function may be written to independently load the user and template:</p>
<div class="numberLines">
<div class="sourceCode" id="cb12"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> <span class="fu">sendMarketingUpdate</span><span class="op">(</span>updateId<span class="op">:</span> <span class="bu">Int</span><span class="op">,</span> userId<span class="op">:</span> <span class="bu">Int</span><span class="op">):</span> <span class="ex">Future</span><span class="op">[</span>MarketingUpdateStatus<span class="op">]</span> <span class="op">=</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">{</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">(</span>user<span class="op">,</span> marketingTemplate<span class="op">)</span> <span class="op">&lt;-</span> <span class="op">(</span><span class="fu">loadUser</span><span class="op">(</span>userId<span class="op">),</span> <span class="fu">loadTemplate</span><span class="op">(</span>updateId<span class="op">)).</span>tupled</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    composedEmail <span class="op">&lt;-</span> <span class="fu">composeEmailForUser</span><span class="op">(</span>user<span class="op">,</span> marketingTemplate<span class="op">)</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>    result <span class="op">&lt;-</span> <span class="fu">sendEmail</span><span class="op">(</span>composedEmail<span class="op">)</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span> <span class="cf">yield</span> result<span class="op">.</span>toMarketingUpdateStatus</span></code></pre></div>
</div>
<p>The code can be trimmed just a little bit more, as well:</p>
<div class="numberLines">
<div class="sourceCode" id="cb13"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> <span class="fu">sendMarketingUpdate</span><span class="op">(</span>updateId<span class="op">:</span> <span class="bu">Int</span><span class="op">,</span> userId<span class="op">:</span> <span class="bu">Int</span><span class="op">):</span> <span class="ex">Future</span><span class="op">[</span>MarketingUpdateStatus<span class="op">]</span> <span class="op">=</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">{</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>    composedEmail <span class="op">&lt;-</span> <span class="op">(</span><span class="fu">loadUser</span><span class="op">(</span>userId<span class="op">),</span> <span class="fu">loadTemplate</span><span class="op">(</span>updateId<span class="op">)).</span><span class="fu">mapN</span><span class="op">(</span>composeEmailForUser<span class="op">)</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>    result <span class="op">&lt;-</span> <span class="fu">sendEmail</span><span class="op">(</span>composedEmail<span class="op">)</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span> <span class="cf">yield</span> result<span class="op">.</span>toMarketingUpdateStatus</span></code></pre></div>
</div>
<p>This means that with applicative functions, you can express imperative code to some degree by gating functions dependent on a set of inputs, such as <code>composeEmailForUser()</code>, and lean on monad’s <code>flatMap()</code> for when you need absolute ordering of computations. These two styles of computation thus complement each other.</p>
<h2 id="becoming-a-monad">Becoming a Monad</h2>
<p>In order to become a <code>Monad</code>, an effect type must implement the typeclass. Let’s implement instances for the usual suspects, <code>Option</code>, <code>Either</code>, and <code>List</code>. As <code>Monad</code> is a specialization of <code>Applicative</code> and thus also <code>Functor</code>, we can simply upgrade our <code>Applicative</code> instances to become <code>Monad</code>s:</p>
<div class="numberLines">
<div class="sourceCode" id="cb14"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">implicit</span> <span class="kw">val</span> optionMonad<span class="op">:</span> Monad<span class="op">[</span><span class="ex">Option</span><span class="op">]</span> <span class="op">=</span> <span class="kw">new</span> Monad<span class="op">[</span><span class="ex">Option</span><span class="op">]</span> <span class="op">{</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">// keep existing definitions</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">override</span> <span class="kw">def</span> flatten<span class="op">[</span>A<span class="op">](</span>ffa<span class="op">:</span> <span class="ex">Option</span><span class="op">[</span><span class="ex">Option</span><span class="op">[</span>A<span class="op">]]):</span> <span class="ex">Option</span><span class="op">[</span>A<span class="op">]</span> <span class="op">=</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>    ffa <span class="cf">match</span> <span class="op">{</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>      <span class="cf">case</span> <span class="bu">Some</span><span class="op">(</span>fa<span class="op">)</span> <span class="op">=&gt;</span> fa</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>      <span class="cf">case</span> <span class="bu">None</span>     <span class="op">=&gt;</span> <span class="bu">None</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a><span class="kw">implicit</span> <span class="kw">def</span> eitherMonad<span class="op">[</span>X<span class="op">]:</span> Monad<span class="op">[</span>Either<span class="op">[</span>X<span class="op">,</span> <span class="op">*]]</span> <span class="op">=</span> <span class="kw">new</span> Monad<span class="op">[</span>Either<span class="op">[</span>X<span class="op">,</span> <span class="op">*]]</span> <span class="op">{</span></span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a>  <span class="co">// keep existing definitions</span></span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a>  <span class="kw">override</span> <span class="kw">def</span> flatten<span class="op">[</span>A<span class="op">](</span>ffa<span class="op">:</span> Either<span class="op">[</span>X<span class="op">,</span> Either<span class="op">[</span>X<span class="op">,</span> A<span class="op">]]):</span> Either<span class="op">[</span>X<span class="op">,</span> A<span class="op">]</span> <span class="op">=</span></span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a>    ffa <span class="cf">match</span> <span class="op">{</span></span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true" tabindex="-1"></a>      <span class="cf">case</span> <span class="fu">Right</span><span class="op">(</span>fa<span class="op">)</span> <span class="op">=&gt;</span> fa</span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true" tabindex="-1"></a>      <span class="cf">case</span> <span class="fu">Left</span><span class="op">(</span>x<span class="op">)</span> <span class="op">=&gt;</span> <span class="fu">Left</span><span class="op">(</span>x<span class="op">)</span></span>
<span id="cb14-20"><a href="#cb14-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb14-21"><a href="#cb14-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb14-22"><a href="#cb14-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-23"><a href="#cb14-23" aria-hidden="true" tabindex="-1"></a><span class="kw">implicit</span> <span class="kw">val</span> listMonad<span class="op">:</span> Monad<span class="op">[</span><span class="ex">List</span><span class="op">]</span> <span class="op">=</span> <span class="kw">new</span> Monad<span class="op">[</span><span class="ex">List</span><span class="op">]</span> <span class="op">{</span></span>
<span id="cb14-24"><a href="#cb14-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-25"><a href="#cb14-25" aria-hidden="true" tabindex="-1"></a>  <span class="co">// keep existing definitions</span></span>
<span id="cb14-26"><a href="#cb14-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-27"><a href="#cb14-27" aria-hidden="true" tabindex="-1"></a>  <span class="kw">override</span> <span class="kw">def</span> flatten<span class="op">[</span>A<span class="op">](</span>ffa<span class="op">:</span> <span class="ex">List</span><span class="op">[</span><span class="ex">List</span><span class="op">[</span>A<span class="op">]]):</span> <span class="ex">List</span><span class="op">[</span>A<span class="op">]</span> <span class="op">=</span></span>
<span id="cb14-28"><a href="#cb14-28" aria-hidden="true" tabindex="-1"></a>    ffa</span>
<span id="cb14-29"><a href="#cb14-29" aria-hidden="true" tabindex="-1"></a>      <span class="op">.</span><span class="fu">foldLeft</span><span class="op">(</span><span class="ex">List</span><span class="op">[</span>A<span class="op">]())</span> <span class="op">{</span> <span class="op">(</span>outerResult<span class="op">,</span> as<span class="op">)</span> <span class="op">=&gt;</span></span>
<span id="cb14-30"><a href="#cb14-30" aria-hidden="true" tabindex="-1"></a>        as<span class="op">.</span><span class="fu">foldLeft</span><span class="op">(</span>outerResult<span class="op">)</span> <span class="op">{</span> <span class="op">(</span>innerResult<span class="op">,</span> a<span class="op">)</span> <span class="op">=&gt;</span></span>
<span id="cb14-31"><a href="#cb14-31" aria-hidden="true" tabindex="-1"></a>          a <span class="op">::</span> innerResult</span>
<span id="cb14-32"><a href="#cb14-32" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb14-33"><a href="#cb14-33" aria-hidden="true" tabindex="-1"></a>      <span class="op">}</span></span>
<span id="cb14-34"><a href="#cb14-34" aria-hidden="true" tabindex="-1"></a>      <span class="op">.</span>reverse</span>
<span id="cb14-35"><a href="#cb14-35" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
<blockquote>
<p>See the instances of <code>Monad</code> for
<a href="https://bitsof.thisfieldwas.green/keywordsalad/embracing-nondeterminism-code/src/branch/part3/src/main/scala/green/thisfieldwas/embracingnondeterminism/data/Option.scala#L159-L218"><code>Option</code></a>,
<a href="https://bitsof.thisfieldwas.green/keywordsalad/embracing-nondeterminism-code/src/branch/part3/src/main/scala/green/thisfieldwas/embracingnondeterminism/data/Either.scala#L114-L174"><code>Either</code></a>,
and <a href="https://bitsof.thisfieldwas.green/keywordsalad/embracing-nondeterminism-code/src/branch/part3/src/main/scala/green/thisfieldwas/embracingnondeterminism/data/List.scala#L239-L302"><code>List</code></a> in the sample repository.</p>
</blockquote>
<p>In the above example, I implemented the <code>Monad</code> instances using <code>flatten()</code>. These could alternatively be implemented using <code>flatMap()</code>. You might try to do this if you wish as an exercise.</p>
<h2 id="monad-laws">Monad laws</h2>
<p>How do we know that <code>Option</code>, <code>Either</code>, and <code>List</code>’s <code>Monad</code> instances are well-behaved as monads? Like functors, <a href="https://en.wikipedia.org/wiki/Monad_(category_theory)#Formal_definition">monads are formally defined</a> in the higher math of <a href="https://en.m.wikipedia.org/wiki/Category_theory">category theory</a> and expected to conform to a set of laws.</p>
<p>There are <strong>three monad laws</strong>, which must hold for all monads in addition to the applicative and functor laws.</p>
<ol type="1">
<li><strong>Preservation of left identity</strong>: Kleisli composition of <code>pure()</code> with a function of form <code>f: A =&gt; F[B]</code> applied to an unlifted argument <code>a: A</code> is the same as applying the unlifted argument directly to <code>f: A =&gt; F[B]</code>.</li>
<li><strong>Preservation of right identity</strong>: Kleisli composition of a function of form <code>f: A =&gt; F[B]</code> with <code>pure()</code> applied to an unlifted argument <code>a: A</code> is the same as applying the unlifted argument directly to <code>f: A =&gt; F[B]</code>.</li>
<li><strong>Associativity</strong>: Kleisli composition of three functions <code>f: A =&gt; F[B]</code>, <code>g: B =&gt; F[C]</code>, and <code>h: C =&gt; F[D]</code> applied to an argument <code>a: A</code> produces the same result regardless of grouping: <code>(f &gt;=&gt; g) &gt;=&gt; h</code> is the same as <code>f &gt;=&gt; (g &gt;=&gt; h)</code>.</li>
</ol>
<p>Note that <code>pure()</code> is interpreted as the identity element of the monad, as it merely lifts a value into its context, unmodified.</p>
<h3 id="defining-monad-laws-as-properties">Defining monad laws as properties</h3>
<p>The monad laws may be defined as <code>scalacheck</code> properties, as <a href="/blog/2022/06/05/permitting-or-halting-computation/#defining-the-applicative-laws-as-properties">previously for applicatives</a>. These properties assert “for all” instances of a particular monad <code>F[_]</code>, the properties should hold. We know we have a well-behaved monad if the property checks pass.</p>
<div class="numberLines">
<div class="sourceCode" id="cb15"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">trait</span> MonadLaws <span class="op">{</span> <span class="kw">this</span><span class="op">:</span> Laws <span class="kw">with</span> ApplicativeLaws <span class="op">=&gt;</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">implicit</span> <span class="kw">def</span> arbitraryFA<span class="op">[</span>F<span class="op">[</span>_<span class="op">]:</span> LiftedGen<span class="op">,</span> A<span class="op">:</span> Arbitrary<span class="op">]:</span> Arbitrary<span class="op">[</span>F<span class="op">[</span>A<span class="op">]]</span> <span class="op">=</span> <span class="fu">Arbitrary</span><span class="op">(</span>arbitrary<span class="op">[</span>A<span class="op">].</span>lift<span class="op">)</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">/**</span> Defined per Monad laws taken from the Haskell wiki<span class="co">:</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">*</span> <span class="co">[[</span>https<span class="co">://</span>wiki<span class="co">.</span>haskell<span class="co">.</span>org<span class="co">/</span>Monad_laws<span class="co">#</span>The_three_laws<span class="co">]]</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">*</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">*</span> These laws extend the Applicative laws<span class="co">,</span> so <span class="co">`</span>checkApplicativeLaws<span class="co">[</span>F<span class="co">]()`</span> should be</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">*</span> executed alongside this function<span class="co">.</span></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">*</span></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">*</span> The laws as defined here leverage Kleisli composition<span class="co">,</span> which is defined</span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">*</span> using the operator <span class="co">`&gt;=&gt;`</span> in terms of <span class="co">`</span>flatMap<span class="co">()`,</span> to better highlight the</span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">*</span> left and right identities and associativity that should be exhibited by</span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">*</span> the composition of monadic operations<span class="co">.</span></span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">*</span></span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">*</span> <span class="co">@</span>param TT The type tag of the context</span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a>    <span class="co">*</span> <span class="co">@</span>tparam F The context type being tested</span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a>    <span class="co">*/</span></span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> checkMonadLaws<span class="op">[</span>F<span class="op">[</span>_<span class="op">]:</span> Monad<span class="op">:</span> LiftedGen<span class="op">]()(</span><span class="kw">implicit</span> TT<span class="op">:</span> TypeTag<span class="op">[</span>F<span class="op">[</span><span class="ex">Any</span><span class="op">]]):</span> <span class="bu">Unit</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true" tabindex="-1"></a>    <span class="fu">property</span><span class="op">(</span><span class="ss">s&quot;${</span>TT<span class="op">.</span>name<span class="ss">}</span><span class="st"> Monad composition preserves left identity</span><span class="ss">&quot;</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb15-21"><a href="#cb15-21" aria-hidden="true" tabindex="-1"></a>      <span class="co">// The identity of Kleisli composition simply lifts a value into the</span></span>
<span id="cb15-22"><a href="#cb15-22" aria-hidden="true" tabindex="-1"></a>      <span class="co">// context. Kleisli composition of a function after `pure()` when applied</span></span>
<span id="cb15-23"><a href="#cb15-23" aria-hidden="true" tabindex="-1"></a>      <span class="co">// to a value will produce the same result as applying the function</span></span>
<span id="cb15-24"><a href="#cb15-24" aria-hidden="true" tabindex="-1"></a>      <span class="co">// directly to the value.</span></span>
<span id="cb15-25"><a href="#cb15-25" aria-hidden="true" tabindex="-1"></a>      <span class="fu">forAll</span><span class="op">(</span><span class="cf">for</span> <span class="op">{</span></span>
<span id="cb15-26"><a href="#cb15-26" aria-hidden="true" tabindex="-1"></a>        a <span class="op">&lt;-</span> arbitrary<span class="op">[</span><span class="bu">Int</span><span class="op">]</span></span>
<span id="cb15-27"><a href="#cb15-27" aria-hidden="true" tabindex="-1"></a>        h <span class="op">&lt;-</span> arbitrary<span class="op">[</span><span class="bu">Int</span> <span class="op">=&gt;</span> F<span class="op">[</span><span class="ex">String</span><span class="op">]]</span></span>
<span id="cb15-28"><a href="#cb15-28" aria-hidden="true" tabindex="-1"></a>      <span class="op">}</span> <span class="cf">yield</span> <span class="op">(</span>a<span class="op">,</span> h<span class="op">))</span> <span class="op">{</span> <span class="cf">case</span> <span class="op">(</span>a<span class="op">,</span> h<span class="op">)</span> <span class="op">=&gt;</span></span>
<span id="cb15-29"><a href="#cb15-29" aria-hidden="true" tabindex="-1"></a>        <span class="kw">val</span> leftIdentity <span class="op">=</span> <span class="op">((</span>_<span class="op">:</span> <span class="bu">Int</span><span class="op">).</span>pure<span class="op">[</span>F<span class="op">])</span> <span class="op">&gt;=&gt;</span> h</span>
<span id="cb15-30"><a href="#cb15-30" aria-hidden="true" tabindex="-1"></a>        <span class="fu">leftIdentity</span><span class="op">(</span>a<span class="op">)</span> mustBe <span class="fu">h</span><span class="op">(</span>a<span class="op">)</span></span>
<span id="cb15-31"><a href="#cb15-31" aria-hidden="true" tabindex="-1"></a>      <span class="op">}</span></span>
<span id="cb15-32"><a href="#cb15-32" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb15-33"><a href="#cb15-33" aria-hidden="true" tabindex="-1"></a>    <span class="fu">property</span><span class="op">(</span><span class="ss">s&quot;${</span>TT<span class="op">.</span>name<span class="ss">}</span><span class="st"> Monad composition preserves right identity</span><span class="ss">&quot;</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb15-34"><a href="#cb15-34" aria-hidden="true" tabindex="-1"></a>      <span class="co">// The identity of Kleisli composition simply lifts a value into the</span></span>
<span id="cb15-35"><a href="#cb15-35" aria-hidden="true" tabindex="-1"></a>      <span class="co">// context. Kleisli composition of `pure()` after a function when applied</span></span>
<span id="cb15-36"><a href="#cb15-36" aria-hidden="true" tabindex="-1"></a>      <span class="co">// to a value will produce the same result as applying the function</span></span>
<span id="cb15-37"><a href="#cb15-37" aria-hidden="true" tabindex="-1"></a>      <span class="co">// directly to the value.</span></span>
<span id="cb15-38"><a href="#cb15-38" aria-hidden="true" tabindex="-1"></a>      <span class="fu">forAll</span><span class="op">(</span><span class="cf">for</span> <span class="op">{</span></span>
<span id="cb15-39"><a href="#cb15-39" aria-hidden="true" tabindex="-1"></a>        a <span class="op">&lt;-</span> arbitrary<span class="op">[</span><span class="bu">Int</span><span class="op">]</span></span>
<span id="cb15-40"><a href="#cb15-40" aria-hidden="true" tabindex="-1"></a>        h <span class="op">&lt;-</span> arbitrary<span class="op">[</span><span class="bu">Int</span> <span class="op">=&gt;</span> F<span class="op">[</span><span class="ex">String</span><span class="op">]]</span></span>
<span id="cb15-41"><a href="#cb15-41" aria-hidden="true" tabindex="-1"></a>      <span class="op">}</span> <span class="cf">yield</span> <span class="op">(</span>a<span class="op">,</span> h<span class="op">))</span> <span class="op">{</span> <span class="cf">case</span> <span class="op">(</span>a<span class="op">,</span> h<span class="op">)</span> <span class="op">=&gt;</span></span>
<span id="cb15-42"><a href="#cb15-42" aria-hidden="true" tabindex="-1"></a>        <span class="kw">val</span> rightIdentity <span class="op">=</span> h <span class="op">&gt;=&gt;</span> <span class="op">((</span>_<span class="op">:</span> <span class="ex">String</span><span class="op">).</span>pure<span class="op">[</span>F<span class="op">])</span></span>
<span id="cb15-43"><a href="#cb15-43" aria-hidden="true" tabindex="-1"></a>        <span class="fu">rightIdentity</span><span class="op">(</span>a<span class="op">)</span> mustBe <span class="fu">h</span><span class="op">(</span>a<span class="op">)</span></span>
<span id="cb15-44"><a href="#cb15-44" aria-hidden="true" tabindex="-1"></a>      <span class="op">}</span></span>
<span id="cb15-45"><a href="#cb15-45" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb15-46"><a href="#cb15-46" aria-hidden="true" tabindex="-1"></a>    <span class="fu">property</span><span class="op">(</span><span class="ss">s&quot;${</span>TT<span class="op">.</span>name<span class="ss">}</span><span class="st"> Monad composition is associative</span><span class="ss">&quot;</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb15-47"><a href="#cb15-47" aria-hidden="true" tabindex="-1"></a>      <span class="co">// `flatMap()` and thus Kleisli composition are both associative.</span></span>
<span id="cb15-48"><a href="#cb15-48" aria-hidden="true" tabindex="-1"></a>      <span class="co">// This means that your program may be factored with these operations</span></span>
<span id="cb15-49"><a href="#cb15-49" aria-hidden="true" tabindex="-1"></a>      <span class="co">// in any arbitrary grouping and the output will be the same.</span></span>
<span id="cb15-50"><a href="#cb15-50" aria-hidden="true" tabindex="-1"></a>      <span class="fu">forAll</span><span class="op">(</span><span class="cf">for</span> <span class="op">{</span></span>
<span id="cb15-51"><a href="#cb15-51" aria-hidden="true" tabindex="-1"></a>        a <span class="op">&lt;-</span> arbitrary<span class="op">[</span><span class="ex">Double</span><span class="op">]</span></span>
<span id="cb15-52"><a href="#cb15-52" aria-hidden="true" tabindex="-1"></a>        f <span class="op">&lt;-</span> arbitrary<span class="op">[</span><span class="ex">Double</span> <span class="op">=&gt;</span> F<span class="op">[</span><span class="ex">String</span><span class="op">]]</span></span>
<span id="cb15-53"><a href="#cb15-53" aria-hidden="true" tabindex="-1"></a>        g <span class="op">&lt;-</span> arbitrary<span class="op">[</span><span class="ex">String</span> <span class="op">=&gt;</span> F<span class="op">[</span><span class="bu">Int</span><span class="op">]]</span></span>
<span id="cb15-54"><a href="#cb15-54" aria-hidden="true" tabindex="-1"></a>        h <span class="op">&lt;-</span> arbitrary<span class="op">[</span><span class="bu">Int</span> <span class="op">=&gt;</span> F<span class="op">[</span><span class="ex">Boolean</span><span class="op">]]</span></span>
<span id="cb15-55"><a href="#cb15-55" aria-hidden="true" tabindex="-1"></a>      <span class="op">}</span> <span class="cf">yield</span> <span class="op">(</span>a<span class="op">,</span> f<span class="op">,</span> g<span class="op">,</span> h<span class="op">))</span> <span class="op">{</span> <span class="cf">case</span> <span class="op">(</span>a<span class="op">,</span> f<span class="op">,</span> g<span class="op">,</span> h<span class="op">)</span> <span class="op">=&gt;</span></span>
<span id="cb15-56"><a href="#cb15-56" aria-hidden="true" tabindex="-1"></a>        <span class="kw">val</span> assocLeft <span class="op">=</span> <span class="op">(</span>f <span class="op">&gt;=&gt;</span> g<span class="op">)</span> <span class="op">&gt;=&gt;</span> h</span>
<span id="cb15-57"><a href="#cb15-57" aria-hidden="true" tabindex="-1"></a>        <span class="kw">val</span> assocRight <span class="op">=</span> f <span class="op">&gt;=&gt;</span> <span class="op">(</span>g <span class="op">&gt;=&gt;</span> h<span class="op">)</span></span>
<span id="cb15-58"><a href="#cb15-58" aria-hidden="true" tabindex="-1"></a>        <span class="fu">assocLeft</span><span class="op">(</span>a<span class="op">)</span> mustBe <span class="fu">assocRight</span><span class="op">(</span>a<span class="op">)</span></span>
<span id="cb15-59"><a href="#cb15-59" aria-hidden="true" tabindex="-1"></a>      <span class="op">}</span></span>
<span id="cb15-60"><a href="#cb15-60" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb15-61"><a href="#cb15-61" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb15-62"><a href="#cb15-62" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
<blockquote>
<p><a href="https://bitsof.thisfieldwas.green/keywordsalad/embracing-nondeterminism-code/src/branch/part3/src/test/scala/green/thisfieldwas/embracingnondeterminism/control/MonadLaws.scala">See here</a> for the definition of the trait.</p>
</blockquote>
<p>Our laws specs can now extend this trait and assert that their tested contexts conform to the monad laws. For example, the laws spec for <code>Option</code>:</p>
<div class="numberLines">
<div class="sourceCode" id="cb16"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> OptionLaws <span class="kw">extends</span> Laws <span class="kw">with</span> FunctorLaws <span class="kw">with</span> ApplicativeLaws <span class="kw">with</span> MonadLaws <span class="op">{</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">import</span> <span class="ex">Option</span><span class="op">.</span>Instances<span class="op">.</span>_</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">implicit</span> <span class="kw">val</span> optionLiftedGen<span class="op">:</span> LiftedGen<span class="op">[</span><span class="ex">Option</span><span class="op">]</span> <span class="op">=</span> <span class="kw">new</span> LiftedGen<span class="op">[</span><span class="ex">Option</span><span class="op">]</span> <span class="op">{</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">override</span> <span class="kw">def</span> lift<span class="op">[</span>A<span class="op">](</span>gen<span class="op">:</span> Gen<span class="op">[</span>A<span class="op">]):</span> Gen<span class="op">[</span><span class="ex">Option</span><span class="op">[</span>A<span class="op">]]</span> <span class="op">=</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>      Gen<span class="op">.</span><span class="fu">lzy</span><span class="op">(</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>        Gen<span class="op">.</span><span class="fu">oneOf</span><span class="op">(</span></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>          Gen<span class="op">.</span><span class="fu">const</span><span class="op">(</span><span class="bu">None</span><span class="op">),</span></span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>          gen<span class="op">.</span><span class="fu">map</span><span class="op">(</span><span class="bu">Some</span><span class="op">(</span>_<span class="op">)),</span></span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>        <span class="op">)</span></span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a>      <span class="op">)</span></span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a>  checkFunctorLaws<span class="op">[</span><span class="ex">Option</span><span class="op">]()</span></span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true" tabindex="-1"></a>  checkApplicativeLaws<span class="op">[</span><span class="ex">Option</span><span class="op">]()</span></span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true" tabindex="-1"></a>  checkMonadLaws<span class="op">[</span><span class="ex">Option</span><span class="op">]()</span></span>
<span id="cb16-19"><a href="#cb16-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
<blockquote>
<p>See the laws specs for <a href="https://bitsof.thisfieldwas.green/keywordsalad/embracing-nondeterminism-code/src/branch/part3/src/test/scala/green/thisfieldwas/embracingnondeterminism/data/OptionSpec.scala#L127-L146">Option</a>,
<a href="https://bitsof.thisfieldwas.green/keywordsalad/embracing-nondeterminism-code/src/branch/part3/src/test/scala/green/thisfieldwas/embracingnondeterminism/data/EitherSpec.scala#L112-L136">Either</a>,
and <a href="https://bitsof.thisfieldwas.green/keywordsalad/embracing-nondeterminism-code/src/branch/part3/src/test/scala/green/thisfieldwas/embracingnondeterminism/data/ListSpec.scala#L159-L181">List</a></p>
</blockquote>
<h3 id="implications-of-the-monad-laws">Implications of the monad laws</h3>
<p>You may have noticed that the characteristics of the monad laws are somewhat different from the functor and applicative laws. They build using composition directly, specifically Kleisli composition, but don’t assert that function composition generally is retained within their contexts the same way that functor or applicative’s laws do.</p>
<p><strong>Let’s reiterate the laws:</strong></p>
<ol type="1">
<li><em>Left identity</em></li>
<li><em>Right identity</em></li>
<li><em>Associativity</em></li>
</ol>
<p>These laws specifically also define another typeclass called a <strong>monoid</strong>, which is a specialization of a <strong>semigroup</strong> that adds an <em>identity</em> or <em>empty</em> element. The identity element is special in that combining it with any other element produces that other element.</p>
<div class="numberLines">
<div class="sourceCode" id="cb17"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">trait</span> Monoid<span class="op">[</span>M<span class="op">]</span> <span class="kw">extends</span> Semigroup<span class="op">[</span>M<span class="op">]</span> <span class="op">{</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> empty<span class="op">:</span> M</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a><span class="kw">object</span> Monoid <span class="op">{</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> apply<span class="op">[</span>M<span class="op">:</span> Monoid<span class="op">]:</span> Monoid<span class="op">[</span>M<span class="op">]</span> <span class="op">=</span> implicitly<span class="op">[</span>Monoid<span class="op">[</span>M<span class="op">]]</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
<p>Monoids are nearly as common as semigroups, as not all semigroups are monoids, and you’ve probably used quite a few of them:</p>
<ul>
<li><a href="https://bitsof.thisfieldwas.green/keywordsalad/embracing-nondeterminism-code/src/branch/part3/src/test/scala/green/thisfieldwas/embracingnondeterminism/stdlib/ListSpec.scala#L80-L88"><code>List</code></a>’s identity element is the empty <code>List()</code>.</li>
<li><a href="https://bitsof.thisfieldwas.green/keywordsalad/embracing-nondeterminism-code/src/branch/part3/src/test/scala/green/thisfieldwas/embracingnondeterminism/stdlib/StringSpec.scala#L21-L29"><code>String</code></a>’s identity element is the empty <code>""</code>.</li>
<li><a href="https://bitsof.thisfieldwas.green/keywordsalad/embracing-nondeterminism-code/src/branch/part3/src/test/scala/green/thisfieldwas/embracingnondeterminism/stdlib/IntegerSpec.scala#L10-L22"><code>Int</code></a>’s identity element is <code>0</code>.</li>
<li><a href="https://bitsof.thisfieldwas.green/keywordsalad/embracing-nondeterminism-code/src/branch/part3/src/test/scala/green/thisfieldwas/embracingnondeterminism/stdlib/SetSpec.scala#L80-L88"><code>Set</code></a>’s identity element is the empty <code>Set()</code>.</li>
</ul>
<p>The key difference between monads and these monoids above is that monads form an <em>additive function</em> in contrast to <em>additive data</em>. Functions of the form <code>A =&gt; F[B]</code> are combinable using <code>&gt;=&gt;</code> to produce new functions of the same form, and this operation is associative, which means that monads form semigroups under Kleisli composition. They form monoids as the <code>pure()</code> function satisfies the identity element in that it doesn’t alter its argument when composed to either the left or right side of a function of the form <code>A =&gt; F[B]</code>.</p>
<blockquote>
<p>To be really pedantic, monads are functors. All functors in Scala are functors from Scala types into other Scala types, making them endofunctors because they map back into the same category: the category of Scala types.</p>
<p>This affirms an infamous joke:</p>
<blockquote>
<p>Haskell gets some resistance due to the complexity of using monads to control side effects. Wadler tries to appease critics by explaining that <em>“a monad is a monoid in the category of endofunctors, what’s the problem?”</em></p>
</blockquote>
<p>– From James Iry’s “<a href="https://web.archive.org/web/20220609203110/https://james-iry.blogspot.com/2009/05/brief-incomplete-and-mostly-wrong.html">A Brief, Incomplete, and Mostly Wrong History of Programming Languages</a>”</p>
</blockquote>
<p>In addition to being monoids, Scala’s
<a href="https://bitsof.thisfieldwas.green/keywordsalad/embracing-nondeterminism-code/src/branch/part3/src/test/scala/green/thisfieldwas/embracingnondeterminism/stdlib/ListSpec.scala#L32-L63"><code>List</code></a> and
<a href="https://bitsof.thisfieldwas.green/keywordsalad/embracing-nondeterminism-code/src/branch/part3/src/test/scala/green/thisfieldwas/embracingnondeterminism/stdlib/SetSpec.scala#L32-L63"><code>Set</code></a> are also monads and I have asserted that they are well behaved with property checks.
<a href="https://bitsof.thisfieldwas.green/keywordsalad/embracing-nondeterminism-code/src/branch/part3/src/test/scala/green/thisfieldwas/embracingnondeterminism/stdlib/OptionSpec.scala#L30-L61"><code>Option</code></a>
and <a href="https://bitsof.thisfieldwas.green/keywordsalad/embracing-nondeterminism-code/src/branch/part3/src/test/scala/green/thisfieldwas/embracingnondeterminism/stdlib/EitherSpec.scala#L30-L61"><code>Either</code></a>
are also monads. You’ve probably been using them as such without realizing!</p>
<p>The real takeaway from the monad laws is that you get <em>imperative computation as a composable structure</em>. You retain referential transparency in that associativity guarantees that your operations may be grouped arbitrarily, allowing you to factor the steps of your program with a large degree of freedom.</p>
<h2 id="what-is-enabled-by-monads">What is enabled by monads?</h2>
<p>The <code>flatMap()</code> function primarily enables imperative programming through abstraction. It strictly requires that its current context be evaluated into its <strong>desired case</strong> before applying its function argument against the term it contains. If the context is in the <strong>undesired case</strong>, then all subsequent computation halts and this case <em>propagates</em> instead. Thus, in contrast to applicative’s <em>all-or-nothing</em> operations, monads offer <em>one-after-another</em> operations. Both evaluation styles complement each other and may be freely mixed, of course.</p>
<h3 id="beware-the-imperative-trap">Beware the imperative trap</h3>
<p>Because monads allow you to express functional programming in a style that closely mirrors procedural code, especially within the syntax of the for comprehension, it’s very easy to fall into a trap of procedural spaghetti even though you’re using a functional programming abstraction. This occurs because for comprehensions allow you to expose multiple terms and pass them around at varying points within the for comprehension, mimicking procedural state-passing:</p>
<div class="numberLines">
<div class="sourceCode" id="cb18"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> <span class="fu">performTransaction</span><span class="op">(</span>accountNo<span class="op">:</span> <span class="ex">Long</span><span class="op">,</span> amount<span class="op">:</span> <span class="ex">Currency</span><span class="op">):</span> <span class="ex">Future</span><span class="op">[</span><span class="bu">Unit</span><span class="op">]</span> <span class="op">=</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">{</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>    account <span class="op">&lt;-</span> <span class="fu">loadAccount</span><span class="op">(</span>accountNo<span class="op">)</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>    transaction <span class="op">&lt;-</span> <span class="fu">beginTransaction</span><span class="op">(</span>account<span class="op">)</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>    balance <span class="op">&lt;-</span> <span class="fu">getBalance</span><span class="op">(</span>account<span class="op">)</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>    newBalance <span class="op">=</span> balance <span class="op">+</span> amount</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>    _ <span class="op">&lt;-</span> <span class="op">{</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> <span class="op">(</span>newBalance <span class="op">&lt;</span> <span class="ex">Currency</span><span class="op">.</span><span class="fu">from</span><span class="op">(</span><span class="dv">0</span><span class="op">))</span> <span class="op">{</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>        <span class="fu">endTransaction</span><span class="op">(</span>transaction<span class="op">)</span></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>          <span class="op">.</span><span class="fu">flatMap</span><span class="op">(</span>_ <span class="op">=&gt;</span> <span class="fu">failTransaction</span><span class="op">(</span><span class="st">&quot;Insufficient funds&quot;</span><span class="op">))</span></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>      <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>        <span class="fu">updateBalance</span><span class="op">(</span>newBalance<span class="op">)</span></span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a>          <span class="op">.</span><span class="fu">flatMap</span><span class="op">(</span>_ <span class="op">=&gt;</span> <span class="fu">endTransaction</span><span class="op">(</span>transaction<span class="op">))</span></span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a>      <span class="op">}</span></span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span> <span class="cf">yield</span> <span class="op">()</span></span></code></pre></div>
</div>
<p>This code would be hard to refactor as there’s a lot of arguments being passed around. It’s procedural code wrapped in a for comprehension! A smell in particular is a <code>Unit</code>-return, as it indicates something is causing side-effects with no way to sense what actions have been performed or what state the total operation finished in.</p>
<h2 id="going-forward">Going forward</h2>
<p>These three abstractions, <strong>functors</strong>, <strong>applicatives</strong>, and <strong>monads</strong>, are just the beginning to a rich series of tools that you can leverage to express solid, maintainable, and provable programs. But you may have noticed a few capabilities are missing so far in this series, such as how to:</p>
<ul>
<li><em>Raise errors</em>, specifically as <strong>undesired cases</strong>, agnostic of context.</li>
<li><em>Recover from errors</em>, transforming <strong>undesired cases</strong> to <strong>desired</strong>, agnostic of context.</li>
<li><em>Attempt an alternate operation</em> if the first one fails.</li>
<li><em>Collect effectful operations</em> agnostic of container.</li>
<li>Allow for <em>partial successes and failures</em> within collective operations.</li>
<li><em>Compose effect types</em> to take advantage of their combined characteristics.</li>
<li><em>Encode DSLs</em> as effects.</li>
</ul>
<p>In my next post, we will explore <strong>raising and recovering from errors</strong> agnostic of context, so that your code may abstract against typeclasses but still be able to force and recover from <strong>undesired cases</strong>.</p>

    </div>
    <div class="page-comments">
  <p><strong>Please share with me your thoughts and feedback!</strong></p>
  <script>
    var remark_config = {
      host: 'https://remark42.thisfieldwas.green',
      site_id: 'thisfieldwas.green',
      url: 'https://thisfieldwas.green/blog/2022/06/17/imperative-computation/'
    }
  </script>
  <script>!function(e,n){for(var o=0;o<e.length;o++){var r=n.createElement("script"),c=".js",d=n.head||n.body;"noModule"in r?(r.type="module",c=".mjs"):r.async=!0,r.defer=!0,r.src=remark_config.host+"/web/"+e[o]+c,d.appendChild(r)} }(remark_config.components||["embed"],document);</script>
  <div id="remark42"></div>
</div>

  </div>
</main>

<footer class="page-footer">
  <div class="content-bound">
    <nav class="main-nav">
  <a href="/">Home</a>
  <a href="/blog/">Blog</a>
  <a href="/resume/">Resume</a>
  <a href="/contact/">Contact</a>
</nav>

    <p class="copyright">Copyright &copy; <span class="copyright-date">2012</span> Logan McGrath. All rights reserved.</p>
    <ul class="acks">
      <li>Site proudly generated by <a href="http://jaspervdj.be/hakyll">Hakyll</a>.</li>
      <li><a href="https://www.flaticon.com/free-icon/grass_2790190">Icon</a> made by <a href="https://www.flaticon.com/authors/good-ware">Good Ware</a> from <a href="https://www.flaticon.com/">Flaticon</a>.</li>
    </ul>
    <p class="generated">This page was rendered from <a href="https://bitsof.thisfieldwas.green/keywordsalad/thisfieldwas.green/src/commit/5b2cf3f/site/_posts/2022-06-17-imperative-computation.md">2022-06-17-imperative-computation.md</a> at commit <a class="commit-link" href="https://bitsof.thisfieldwas.green/keywordsalad/thisfieldwas.green/src/commit/5b2cf3f">5b2cf3f</a>.</p>
  </div>
</footer>

</body>
</html>
